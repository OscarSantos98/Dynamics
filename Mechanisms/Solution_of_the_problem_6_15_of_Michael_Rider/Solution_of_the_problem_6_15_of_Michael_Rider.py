# Solution of the problem 6-15 of Michael Rider book, using the methods of dynamics of rigid bodies.
# Oscar Alberto Santos Mu√±oz
# Libraries
import sympy as sp
# In the next line the values of the magnitude of the vectors are introduced.
a2, a3, a4, a5, a6, b3 = 70, 100, 80, 120, 100, 65
print("Links length of the mechanism\na2 =",a2,"\na3 =",a3,"\na4 =",a4,"\na5 =",a5,"\na6 =",a6,"\nb3 =",b3)
theta2 = (95*sp.pi/180).evalf()
theta3 = (4.63498*sp.pi/180).evalf()
theta4 = (76.57626*sp.pi/180).evalf()
theta5 = (-7.2327*sp.pi/180).evalf()
theta6 = (105.74221*sp.pi/180).evalf()
beta = (35.18382*sp.pi/180).evalf()
# Create alpha, beta and theta strings
th_str = []
w_str = []
alp_str = []
for i in range(2,7):
	th_str.append(chr(952) + str(i))
	w_str.append(chr(969) + str(i))
	alp_str.append(chr(945) + str(i))
print("Angles\n",th_str[0]," =",theta2,"\n",th_str[1]," =",theta3,"\n",th_str[2]," =",theta4,"\n",th_str[3]," =",theta5,"\n",th_str[4]," =",theta6,"\n",chr(946)," =",beta)
# The necessary position vectors will be computed.
rCO21 = sp.Matrix(1,3,[a2*sp.cos(theta2),a2*sp.sin(theta2),0])
rDC = sp.Matrix(1,3,[a3*sp.cos(theta3),a3*sp.sin(theta3),0])
rDO41 = sp.Matrix(1,3,[a4*sp.cos(theta4),a4*sp.sin(theta4),0])
rPC = sp.Matrix(1,3,[b3*sp.cos(theta3+beta),b3*sp.sin(theta3+beta),0])
rFP = sp.Matrix(1,3,[a5*sp.cos(theta5),a5*sp.sin(theta5),0])
rFO61 = sp.Matrix(1,3,[a6*sp.cos(theta6),a6*sp.sin(theta6),0])
print("Position vectors\nrCO21 =",rCO21,"\nrDC =",rDC,"\nrDO41 =",rDO41,"\nrPC =",rPC,"\nrFP =",rFP,"\nrFO61 =",rFO61)
# Velocity analysis: Definition of the angular velocities.
w2, w3, w4, w5, w6 = sp.symbols('w2 w3 w4 w5 w6')
omega2 = sp.Matrix(1,3,[0,0,9])
omega3 = sp.Matrix(1,3,[0,0,w3])
omega4 = sp.Matrix(1,3,[0,0,w4])
omega5 = sp.Matrix(1,3,[0,0,w5])
omega6 = sp.Matrix(1,3,[0,0,w6])
print("Angular velocities\n",w_str[0],"=",omega2,"\n",w_str[1],"=",omega3,"\n",w_str[2],"=",omega4,"\n",w_str[3],"=",omega5,"\n",w_str[4],"=",omega6)
VC = omega2.cross(rCO21)
VD1 = VC + omega3.cross(rDC)
VD2 = omega4.cross(rDO41)
print("Point velocities\nVC = ",w_str[0]," x rCO21 = ",VC,"\nVD1 = VC + ",w_str[1]," x rDC = ",VD1,"\nVD2 = ",w_str[2]," x rDO41 = ",VD2)
Eqv1 = sp.Eq(VD1[0],VD2[0])
Eqv2 = sp.Eq(VD1[1],VD2[1])
answ = sp.solve([Eqv1,Eqv2])
print("Solution for w3 and w4 of matching velocity equations of point D\n",answ)
omega3 = omega3.subs(w3,answ[w3])
omega4 = omega4.subs(w4,answ[w4])
print("Substituting w3 and w4 in vectors",w_str[1]," and ",w_str[2],"\n",w_str[1],"=",omega3,"\n",w_str[2],"=",omega4)
VP = VC + omega3.cross(rPC)
VF1 = VP + omega5.cross(rFP)
VF2 = omega6.cross(rFO61)
print("Point velocities\nVP = VC + ",w_str[1]," x rPC = ",VP,"\nVF1 = VP + ",w_str[3]," x rFP = ",VF1,"\nVF2 = ",w_str[4]," x rFO61 = ",VF2)
Eqv3 = sp.Eq(VF1[0],VF2[0])
Eqv4 = sp.Eq(VF1[1],VF2[1])
answ2 = sp.solve([Eqv3,Eqv4])
print("Solution for w5 and w6 of matching velocity equations of point F\n",answ2)
omega5 = omega5.subs(w5,answ2[w5])
omega6 = omega6.subs(w6,answ2[w6])
print("Substituting w5 and w6 in vectors",w_str[3]," and ",w_str[4],"\n",w_str[3],"=",omega5,"\n",w_str[4],"=",omega6)
# Acceleration analysis. Definition of the angular accelerations.
aa2, aa3, aa4, aa5, aa6 = sp.symbols('aa2 aa3 aa4 aa5 aa6')
alpha2 = sp.Matrix(1,3,[0,0,0])
alpha3 = sp.Matrix(1,3,[0,0,aa3])
alpha4 = sp.Matrix(1,3,[0,0,aa4])
alpha5 = sp.Matrix(1,3,[0,0,aa5])
alpha6 = sp.Matrix(1,3,[0,0,aa6])
print("Angular accelerations\n",alp_str[0],"=",alpha2,"\n",alp_str[1],"=",alpha3,"\n",alp_str[2],"=",alpha4,"\n",alp_str[3],"=",alpha5,"\n",alp_str[4],"=",alpha6)
AC = alpha2.cross(rCO21) + omega2.cross(omega2.cross(rCO21))
AD3 = AC + alpha3.cross(rDC) + omega3.cross(omega3.cross(rDC))
AD4 = alpha4.cross(rDO41) + omega4.cross(omega4.cross(rDO41))
print("Point accelerations\nAC = ",alp_str[0]," x rCO21 + ",w_str[0]," x ",w_str[0]," x rCO21 = ",AC,"\nAD3 = AC + ",alp_str[1]," x rDC + ",w_str[1]," x ",w_str[1]," x rDC = ",AD3,"\nAD4 = ",alp_str[2]," x rDO41 + ",w_str[2]," x ",w_str[2]," x rDO41 = ",AD4)
Eqa1 = sp.Eq(AD3[0],AD4[0])
Eqa2 = sp.Eq(AD3[1],AD4[1])
ansa = sp.solve([Eqa1,Eqa2])
print("Solution for aa3 and aa4 of matching accelerations equations of point D\n",ansa)
alpha3 = alpha3.subs(aa3,ansa[aa3])
alpha4 = alpha4.subs(aa4,ansa[aa4])
print("Substituting aa3 and aa4 in vectors",alp_str[1]," and ",alp_str[2],"\n",alp_str[1],"=",alpha3,"\n",alp_str[2],"=",alpha4)
AP3 = AC + alpha3.cross(rPC) + omega3.cross(omega3.cross(rPC))
AF5 = AP3 + alpha5.cross(rFP) + omega5.cross(omega5.cross(rFP))
AF6 = alpha6.cross(rFO61) + omega6.cross(omega6.cross(rFO61))
print("Point accelerations\nAP3 = AC + ",alp_str[1]," x rPC + ",w_str[1]," x ",w_str[1]," x rPC = ",AP3,"\nAF5 = AP3 + ",alp_str[3]," x rFP + ",w_str[3]," x ",w_str[3]," x rFP = ",AF5,"\nAF6 = ",alp_str[4]," x rFO61 + ",w_str[4]," x ",w_str[4]," x rFO61 = ",AF6)
Eqa3 = sp.Eq(AF5[0],AF6[0])
Eqa4 = sp.Eq(AF5[1],AF6[1])
ansa2 = sp.solve([Eqa3,Eqa4])
print("Solution for aa5 and aa6 of matching accelerations equations of point F\n",ansa2)
alpha5 = alpha5.subs(aa5,ansa2[aa5])
alpha6 = alpha6.subs(aa6,ansa2[aa6])
print("Substituting aa5 and aa6 in vectors",alp_str[3]," and ",alp_str[4],"\n",alp_str[3],"=",alpha5,"\n",alp_str[4],"=",alpha6)